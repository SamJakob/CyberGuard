package com.samjakob.cyberguard.platform.secure_storage_delegate.scheme;

import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Build;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyInfo;
import android.security.keystore.KeyProperties;
import android.security.keystore.UserNotAuthenticatedException;

import androidx.annotation.NonNull;
import androidx.biometric.BiometricPrompt;

import com.samjakob.cyberguard.BuildConfig;
import com.samjakob.cyberguard.MainActivity;
import com.samjakob.cyberguard.errors.SecureStorageDelegateError;

import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public interface EncryptionScheme {

    void generateKeyPair(MainActivity mainActivity, Context context, KeyStore appKeyStore, String name);

    @NonNull
    BiometricPrompt.CryptoObject createCryptoObject(@NonNull KeyStore appKeyStore, @NonNull String keyName) throws UserNotAuthenticatedException;

    @NonNull
    byte[] encrypt(@NonNull KeyStore appKeyStore, @NonNull String keyName, byte[] data);
    @NonNull
    byte[] decrypt(BiometricPrompt.CryptoObject cryptoObject, byte[] data);

    /**
     * Used to perform a test of the {@link #encrypt(KeyStore, String, byte[])} and
     * {@link #decrypt(BiometricPrompt.CryptoObject, byte[])} devices at runtime, before they are
     * used to encrypt user data.
     * <p>
     * During development, some devices were found to have problems decrypting data that was
     * successfully encrypted. This would obviously present problems for a user and their
     * experience.
     * <p>
     * This test should simply return cleanly on success, otherwise a runtime exception should be
     * thrown (this is to encourage runtime exceptions to be caught which is done throughout the
     * security implementation to prevent oracle attacks, etc.,).
     * <p>
     * You MUST implement this test on any {@link EncryptionScheme}. Additionally, this MUST NOT
     * trigger any biometric prompts which could be confusing (or concerning) to a user so DO NOT
     * require user interaction for the ephemeral keys generated during this test.
     *
     * @param context The app context (used to test for compatibility).
     * @param appKeyStore The application keystore. Used to generate (and clean up) keys used to
     *                    test with.
     */
    void performEncryptionTest(Context context, KeyStore appKeyStore);

    /**
     * A generic implementation for {@link #performEncryptionTest(Context, KeyStore)} that can be
     * used for Cipher invocations where a Trusted Execution Environment (or Secure Enclave) is
     * expected to generate keys.
     * @param context The application context.
     * @param algorithm The algorithm to use to generate the key.
     * @param keySize The size of the key that will be generated by the implementation.
     * @param padding The padding (see {@link KeyProperties}) that will be used.
     * @param digest The digest (see {@link KeyProperties}) that will be used.
     * @param transformation The transformation string (e.g., RSA/ECB/PKCS1Padding).
     */
    static void teeCipherTest(
        Context context,
        KeyStore appKeyStore,
        String algorithm,
        int keySize,
        String padding,
        String digest,
        String transformation
    ) {
        final String TEST_KEY_ALIAS = "TEMPORARY_TEST_KEY";
        final String TEST_KEY_PAYLOAD = "Howdy, pardner!";

        try {
            // Generate a simple key that is similar to that used by the implementation.
            // We cannot simply reuse the above because it sets additional security requirements that
            // needn't be tested and would cause poor UX if they were (but must be set for
            // implementation).
            KeyGenParameterSpec.Builder keySpecBuilder = new KeyGenParameterSpec.Builder(
                TEST_KEY_ALIAS, KeyProperties.PURPOSE_DECRYPT
            ).setKeySize(keySize);

            if (padding != null) {
                keySpecBuilder = keySpecBuilder.setEncryptionPaddings(padding);
            }

            if (digest != null) {
                keySpecBuilder = keySpecBuilder.setDigests(digest);
            }

            // If there is a StrongBox implementation on the device, and the
            // setIsStrongBoxBacked API is supported by the device call
            // setIsStrongBoxBacked to use it.
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P &&
                    context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE)) {
                keySpecBuilder = keySpecBuilder.setIsStrongBoxBacked(true);
            }

            // Generate the keypair.
            KeyPairGenerator generator = KeyPairGenerator.getInstance(algorithm, "AndroidKeyStore");
            generator.initialize(keySpecBuilder.build());
            KeyPair ephemeralTestKeyPair = generator.generateKeyPair();

            // Get and verify the key information.
            // (e.g., ensure the device actually did generate the key with a secure module).
            KeyFactory factory = KeyFactory.getInstance(ephemeralTestKeyPair.getPrivate().getAlgorithm());
            KeyInfo keyInfo = factory.getKeySpec(ephemeralTestKeyPair.getPrivate(), KeyInfo.class);

            boolean isSecureKey;
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                // The key is secure if the key is protected by at least a trusted environment.
                isSecureKey = (keyInfo.getSecurityLevel() >= KeyProperties.SECURITY_LEVEL_TRUSTED_ENVIRONMENT)
                        // Or, if the exact nature of security is unknown but it is guaranteed to be
                        // SECURITY_LEVEL_TRUSTED_ENVIRONMENT.
                        || keyInfo.getSecurityLevel() == KeyProperties.SECURITY_LEVEL_UNKNOWN_SECURE;
            } else {
                // On older systems fallback to checking isInsideSecureHardware.
                // This has been replaced on newer OS builds by getSecurityLevel.
                isSecureKey = keyInfo.isInsideSecureHardware();
            }

            if (!isSecureKey) {
                throw new SecureStorageDelegateError("The device generated the key incorrectly.");
            }

            // Create encryption cipher.
            Cipher cipher = Cipher.getInstance(transformation);
            cipher.init(Cipher.ENCRYPT_MODE, ephemeralTestKeyPair.getPublic());
            byte[] encrypted = cipher.doFinal(TEST_KEY_PAYLOAD.getBytes(StandardCharsets.UTF_8));

            // Create decryption cipher.
            cipher = Cipher.getInstance(transformation);
            cipher.init(Cipher.DECRYPT_MODE, ephemeralTestKeyPair.getPrivate());

            // Perform final decryption and compare it to the original payload.
            if (!new String(cipher.doFinal(encrypted)).equals(TEST_KEY_PAYLOAD)) {
                throw new GeneralSecurityException("The test decryption failed.");
            }

            if (appKeyStore.containsAlias(TEST_KEY_ALIAS)) appKeyStore.deleteEntry(TEST_KEY_ALIAS);
        } catch (Exception ex) {
            try {
                if (appKeyStore.containsAlias(TEST_KEY_ALIAS)) appKeyStore.deleteEntry(TEST_KEY_ALIAS);
            } catch(Exception ignored) {}

            if (BuildConfig.DEBUG) ex.printStackTrace();
            throw new SecureStorageDelegateError(
                "Your device's encryption implementation has issues. We've downgraded to weaker " +
                "security levels for compatibility."
            );
        }
    }

    /**
     * See {@link #teeCipherTest(Context, KeyStore, String, int, String, String, String)}.
     * This is the equivalent for Ciphers that do not have their keys generated in a trusted
     * execution environment (TEE).
     * @param algorithm The algorithm to check.
     * @param keySize The key size to pass to KeyGenerator (ususally in bits).
     * @param transformation The transformation string to initialize {@link Cipher} with.
     * @param withIV Whether an IV should be generated for this Cipher.
     */
    static void cipherTest(
        String algorithm,
        int keySize,
        String transformation,
        boolean withIV
    ) {
        try {
            // Generate a random key.
            KeyGenerator keyGenerator = KeyGenerator.getInstance(algorithm);
            keyGenerator.init(keySize);
            SecretKey key = keyGenerator.generateKey();

            IvParameterSpec ivParameterSpec = null;
            if (withIV) {
                // Initialize secure RNG.
                SecureRandom secureRandom = null;
                try {
                    // If the SDK and device support it, use getInstanceStrong.
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
                        secureRandom = SecureRandom.getInstanceStrong();
                } catch (Exception ignored) {}
                // Otherwise, ignore exceptions and fall back to the legacy SecureRandom constructor,
                // if it wasn't already initialized.
                if (secureRandom == null) secureRandom = new SecureRandom();

                // Generate a secure random initialization vector.
                byte[] iv = new byte[16];
                secureRandom.nextBytes(iv);
                ivParameterSpec = new IvParameterSpec(iv);
            }

            Cipher cipher = Cipher.getInstance(transformation);

            // Fake payload.
            byte[] payload = new byte[]{ 0, 1, 2, 3, 4, 5, 6, 7 };

            if (withIV) cipher.init(Cipher.ENCRYPT_MODE, key, ivParameterSpec);
            else cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedData = cipher.doFinal(payload);

            if (withIV) cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);
            else cipher.init(Cipher.DECRYPT_MODE, key);
            if (!Arrays.equals(cipher.doFinal(encryptedData), payload)) {
                throw new SecureStorageDelegateError();
            }
        } catch (Exception ex) {
            if (BuildConfig.DEBUG) ex.printStackTrace();
            throw new SecureStorageDelegateError(
                "Your device's encryption implementation has issues. We've downgraded to weaker " + //
                "security levels for compatibility." //
            );
        }
    }

    /**
     * See {@link #teeCipherTest(Context, KeyStore, String, int, String, String, String)}.
     * This is the equivalent for {@link Mac}.
     * @param algorithm The algorithm to check.
     */
    static void macTest(String algorithm) {
        try {
            // Initialize secure RNG.
            SecureRandom secureRandom = null;
            try {
                // If the SDK and device support it, use getInstanceStrong.
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
                    secureRandom = SecureRandom.getInstanceStrong();
            } catch (Exception ignored) {}
            // Otherwise, ignore exceptions and fall back to the legacy SecureRandom constructor,
            // if it wasn't already initialized.
            if (secureRandom == null) secureRandom = new SecureRandom();

            // Test generating key with SecureRandom.
            byte[] key = new byte[32];
            secureRandom.nextBytes(key);

            // Fake payload.
            byte[] payload = new byte[]{ 0, 1, 2, 3, 4, 5, 6, 7 };

            // Generate the MAC.
            Mac mac = Mac.getInstance(algorithm);
            mac.init(new SecretKeySpec(key, algorithm));
            mac.doFinal(payload);
        } catch (Exception ex) {
            if (BuildConfig.DEBUG) ex.printStackTrace();
            throw new SecureStorageDelegateError(
                "Your device's encryption implementation has issues. We've downgraded to weaker " + //
                "security levels for compatibility." //
            );
        }
    }

}
